#pragma config(UART_Usage, UART1, uartVEXLCD, baudRate19200, IOPins, None, None)
#pragma config(UART_Usage, UART2, uartNotUsed, baudRate4800, IOPins, None, None)
#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    gyro,           sensorGyro)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           btmShooter,    tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           frontL,        tmotorVex393HighSpeed_MC29, openLoop, encoderPort, I2C_2)
#pragma config(Motor,  port3,           backL,         tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port4,           leftIntake,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           arm,           tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           rightIntake,   tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           backR,         tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           frontR,        tmotorVex393HighSpeed_MC29, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port10,          topShooter,    tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

void autoForward(int dis, int speed);
void autoTurnLeft(int deg, int speed);
void autoTurnRight(int deg, int speed);
void autoBackward(int dis, int speed);
void autoShooter();
void autoIntakeTop();// TODO add encoders // rename left/right to top and btm intakes
void autoIntakeBtm();// TODO add encoders
void autoArm();
void resetEncoders();
void resetGyroo();
void setGyro();

void BlueFlagSide();
void BlueNotFlagSide();
void RedFlagSide();
void RedNotFlagSide();
void NoAutonomous();

int stage = 0;
bool lCheck, rCheck = false;

void drive();
void tankDrive();
void arcadeDrive();
void lowShooter();
void highShooter();
void lift();
void intakeTop();
void intakeBtm();

bool toggleOn = false; //drive toggle
bool togglePressed = false;

const short leftButton = 1;
const short centerButton = 2;
const short rightButton = 4;
int count = 0;
void waitForPress();
void waitForRelease();



void pre_auton(){
	bStopTasksBetweenModes = true;
	//Declare count variable to keep track of our choice
	bLCDBacklight = true;
	//------------- Beginning of User Interface Code ---------------
	//Clear LCD
	clearLCDLine(0);
	clearLCDLine(1);

	//Loop while center button is not pressed

	while(nLCDButtons != centerButton)
	{

		//Switch case that allows the user to choose from 4 different options
		switch(count){
		case 0:
			//Display first choice
			displayLCDCenteredString(0, "BlueFlagSide");
			displayLCDCenteredString(1, "<         Enter        >");
			waitForPress();
			//Increment or decrement "count" based on button press
			if(nLCDButtons == leftButton)
			{
				waitForRelease();
				count = 4;
			}
			else if(nLCDButtons == rightButton)
			{
				waitForRelease();
				count++;
			}
			break;
		case 1:
			//Display second choice
			displayLCDCenteredString(0, "BlueNotFlagSide");
			displayLCDCenteredString(1, "<         Enter        >");
			waitForPress();
			//Increment or decrement "count" based on button press
			if(nLCDButtons == leftButton)
			{
				waitForRelease();
				count--;
			}
			else if(nLCDButtons == rightButton)
			{
				waitForRelease();
				count++;
			}
			break;
		case 2:
			//Display third choice
			displayLCDCenteredString(0, "RedFlagSide");
			displayLCDCenteredString(1, "<         Enter        >");
			waitForPress();
			//Increment or decrement "count" based on button press
			if(nLCDButtons == leftButton)
			{
				waitForRelease();
				count--;
			}
			else if(nLCDButtons == rightButton)
			{
				waitForRelease();
				count++;
			}
			break;
		case 3:
			//Display fourth choice
			displayLCDCenteredString(0, "RedNotFlagSide");
			displayLCDCenteredString(1, "<         Enter        >");
			waitForPress();
			//Increment or decrement "count" based on button press
			if(nLCDButtons == leftButton)
			{
				waitForRelease();
				count--;
			}
			else if(nLCDButtons == rightButton)
			{
				waitForRelease();
				count++;
			}
			break;
		case 4:
			//Display fourth choice
			displayLCDCenteredString(0, "No Autonomous");
			displayLCDCenteredString(1, "<        Enter        >");
			waitForPress();
			//Increment or decrement "count" based on button press
			if(nLCDButtons == leftButton)
			{
				waitForRelease();
				count--;
			}
			else if(nLCDButtons == rightButton)
			{
				waitForRelease();
				count = 0;
			}
			break;
		default:
			count = -1;
			break;
		}
		bLCDBacklight = false;
	}

	//------------- End of User Interface Code ---------------------

}

task autonomous(){
	//Clear LCD
	clearLCDLine(0);
	clearLCDLine(1);
	//Switch Case that actually runs the user choice

	switch(count){
		//this case is the autonomous for the blue side closest to flag
	case 0:
		//If count = 0, run the code correspoinding with choice 1
		displayLCDCenteredString(0, "BlueFlagSide");
		displayLCDCenteredString(1, "is running!");

		BlueFlagSide();

		break;
		//this case is the autonomous for the blue side away from flag
	case 1:
		//If count = 1, run the code correspoinding with choice 2
		displayLCDCenteredString(0, "BlueNotFlagSide");
		displayLCDCenteredString(1, "is running!");

		BlueNotFlagSide();

		break;
		//this case is the autonomous for the red side near the flag
	case 2:
		//If count = 2, run the code correspoinding with choice 3
		displayLCDCenteredString(0, "RedFlagSide");
		displayLCDCenteredString(1, "is running!");

		RedFlagSide();

		break;
		//this case is the autonomous for the red side away from flag
	case 3:
		//If count = 3, run the code correspoinding with choice 4
		displayLCDCenteredString(0, "RedNotFlagSide");
		displayLCDCenteredString(1, "is running!");

		RedNotFlagSide();

		break;
		//this case is for the potential instance where we would not want to run an autonomous
	case 4:
		//If count = 3, run the code correspoinding with choice 5
		displayLCDCenteredString(0, "NoAutonomous");
		displayLCDCenteredString(1, "is running!");

		NoAutonomous();

		//break;
	default:
		displayLCDCenteredString(0, "You Idiot!");
		displayLCDCenteredString(1, "it broke");
		break;
	}
	//------------- End of Robot Autonomous Movement Code -----------------------
}
task usercontrol(){

	while (true)
	{
		arcadeDrive();
		lift();
		intakeTop();
		intakeBtm();
		
	}

}

//Wait for Press--------------------------------------------------
void waitForPress()
{
	while(nLCDButtons == 0)
	{
		wait1Msec(5);
	}
}
//----------------------------------------------------------------

//Wait for Release------------------------------------------------
void waitForRelease()
{
	while(nLCDButtons != 0)
	{
		wait1Msec(5);
	}
}
//----------------------------------------------------------------

//----------------------------------------------------------------
void BlueFlagSide(){
	autoTurnRight(900,75);
	//	autoForward(3000,75);
	//wait1Msec(1);
	//autoBackward(-1000,-75);
}
void BlueNotFlagSide(){}
void RedFlagSide(){}
void RedNotFlagSide(){}
void NoAutonomous(){}
//-----------------------------------------------------------------
void autoForward(int dis, int speed){
	while(getMotorEncoder(frontL) < dis)
	{
		motor[frontR] = speed;
		motor[frontL] = speed;
	}

	motor[frontR] = 0;
	motor[frontL] = 0;
	resetMotorEncoder(frontL);
	resetMotorEncoder(frontR);
}
void autoBackward(int dis, int speed){
	while(getMotorEncoder(frontL) > dis)
	{
		motor[frontR] = speed;
		motor[frontL] = speed;
	}

	motor[frontR] = 0;
	motor[frontL] = 0;
	resetMotorEncoder(frontL);
	resetMotorEncoder(frontR);
}
void autoTurnRight(int deg, int speed){
	while (abs(SensorValue[gyro]) <= deg){
		motor[frontL]= 60;
		motor[backL]= 60;
		motor[frontR]= -60;
		motor[backR]= -60;
	}
	motor[frontL]= 0;
	motor[backL]= 0;
	motor[frontR]=0;
	motor[backR]= 0;
}
//-----------------------------------------------------------------
void tankDrive(){
	motor[frontL] = vexRT[Ch3];

	motor[backL] = vexRT[Ch3];

	motor[frontR] = vexRT[Ch2];

	motor[backR] = vexRT[Ch2];
}
void arcadeDrive(){
	motor[frontL] = (vexRT[Ch3] + vexRT[Ch1]) / 2;
	motor[backL] = (vexRT[Ch3] + vexRT[Ch1]) / 2;

	motor[frontR] = (vexRT[Ch3] - vexRT[Ch1]) / 2;
	motor[backR] = (vexRT[Ch3] - vexRT[Ch1]) / 2;
}
void drive(){
	if(vexRT[Btn8D] == 1)  // if Btn8D is pressed:
	{
		if (!togglePressed) {
			toggleOn = !toggleOn;
			togglePressed = true;
		}
		} else {
		togglePressed = false;
	}
	if (toggleOn) {
		tankDrive();
		} else {
		arcadeDrive();
	}
}

void lift(){
	motor[arm] = vexRT(Btn5D) * 75 - vexRT(Btn5U) * 75;

}
void intakeTop(){
	motor[leftIntake] = vexRT (Btn6U) * 75 - vexRT(Btn6D) * 75;
}
void intakeBtm(){
	motor[rightIntake] = vexRT(Btn6U) * 75 - vexRT(Btn6D) * 75;
}
void highShooter(){
	//	motor[btmShooter] = vexRT (Btn7U) * 127 - vexRT(Btn7D) * 127;
	//	motor[topShooter] = vexRT (Btn7U) * 127 - vexRT(Btn7D) * 127;
	// ToggleButtonForIntake
	if (vexRT[Btn7U]==1) {
		if (!togglePressed) {
			toggleOn = !toggleOn;
			togglePressed = true;
		}
		} else {
		togglePressed = false;
	}
	if (toggleOn) {

		motor[topShooter] = -127;
		motor[btmShooter] = -127;
		} else {
		motor[topShooter] = 0;
		motor[btmShooter] = 0;
	}
}
void lowShooter(){
	//	motor[btmShooter] = vexRT (Btn7U) * 127 - vexRT(Btn7D) * 127;
	//	motor[topShooter] = vexRT (Btn7U) * 127 - vexRT(Btn7D) * 127;
	// ToggleButtonForIntake
	if (vexRT[Btn7D]==1) {
		if (!togglePressed) {
			toggleOn = !toggleOn;
			togglePressed = true;

		}
		} else {
		togglePressed = false;
	}
	if (toggleOn) {

		motor[topShooter] = -80;
		motor[btmShooter] = -80;
		} else {
		motor[topShooter] = 0;
		motor[btmShooter] = 0;
	}
}


/*
if(vexRT[Btn5U] == 1)  // if Btn5U is pressed:
{
motor[rightMotor] = 0;  // stop 'rightMotor'
motor[leftMotor]  = 0;  // stop 'leftMotor'
}
*/
